{"version":3,"file":"static/webpack/static\\development\\pages\\home.js.ff245ab4c7b460278681.hot-update.js","sources":["webpack:///./src/components/table/utils.js"],"sourcesContent":["import { TYPES } from 'src/components/data'\r\nimport Input from '@material-ui/core/Input';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport Select from '@material-ui/core/Select';\r\n\r\n\r\nconst getValue = (key, values) => {\r\n    return values[key] || 0\r\n}\r\n\r\nconst iOneOf = (keys, arr) => keys.some(key => arr.includes(key));\r\n\r\nconst getCalculateNewValues = (key, value, tableValues) => {\r\n    const keys = [key]\r\n    const newValues = Object.assign({}, tableValues, { [key]: value });\r\n    // All if's here\r\n    if (iOneOf(keys, ['d10', 'd11'])) { // d12\r\n        newValues['d12'] = getValue('d10', newValues) - getValue('d11', newValues);\r\n        keys.push('d12');\r\n    }\r\n    if (tableValues.d21 && tableValues.d22) { // d23\r\n        newValues['d23'] = tableValues.d21 - tableValues.d22\r\n    }\r\n    if (tableValues.e30 && tableValues.d32) { // e32\r\n        newValues['e32'] = tableValues.e30 * tableValues.d32\r\n    }\r\n    if (tableValues.e30 && tableValues.d32) { // f32\r\n        newValues['f32'] = tableValues.e30 * tableValues.d32\r\n    }\r\n    if (tableValues.f32 && tableValues.d32 && tableValues.d34) { // f34\r\n        newValues['f34'] = tableValues.f32 / tableValues.d32 * tableValues.d34\r\n    }\r\n    if (tableValues.f32 && tableValues.d32 && tableValues.d35) { // f35\r\n        newValues['f35'] = tableValues.f32 / tableValues.d32 * tableValues.d35\r\n    }\r\n    if (tableValues.f32 && tableValues.d32 && tableValues.d36) { // f36\r\n        newValues['f36'] = tableValues.f32 / tableValues.d32 * tableValues.d36\r\n    }\r\n    if (tableValues.f32 && tableValues.d32 && tableValues.d37) { // f37\r\n        newValues['f37'] = tableValues.f32 / tableValues.d32 * tableValues.d37\r\n    }\r\n    if (tableValues.f32 && tableValues.d32 && tableValues.d38) { // f38\r\n        newValues['f38'] = tableValues.f32 / tableValues.d32 * tableValues.d38\r\n    }\r\n    if (tableValues.f32 && tableValues.d32 && tableValues.d39) { // f39\r\n        newValues['f39'] = tableValues.f32 / tableValues.d32 * tableValues.d39\r\n    }\r\n    if (tableValues.e30) { // d47\r\n        newValues['d47'] = tableValues.e30\r\n    }\r\n    if (tableValues.d49) { // d48\r\n        newValues['d48'] = tableValues.d49 / 560 / 1000\r\n    }\r\n    if (tableValues.e49) { // e48\r\n        newValues['e48'] = tableValues.e49 / 560 / 1000\r\n    }\r\n    if (tableValues.d11 && tableValues.d23) { // d49 AND e49\r\n        newValues['e49'] = tableValues.d11 * tableValues.d23 * 1000\r\n    }\r\n    if (tableValues.d49) { // d50 \r\n        newValues['d50'] = tableValues.d49 * 0.000330693393472\r\n    }\r\n    if (tableValues.e49) { // e50\r\n        newValues['e50'] = tableValues.e49 * 0.000330693393472\r\n    }\r\n    if (tableValues.d48 && tableValues.d52) { // d51\r\n        newValues['d51'] = tableValues.d48 + tableValues.d52\r\n    }\r\n    if (tableValues.e48 && tableValues.e52) { // e51\r\n        newValues['e51'] = tableValues.e48 + tableValues.e52\r\n    }\r\n    if (tableValues.d48 && tableValues.d47) { // d52\r\n        newValues['d52'] = tableValues.d48 * (1 / tableValues.d47)\r\n    }\r\n    if (tableValues.e48 && tableValues.e47) { // e52\r\n        newValues['e52'] = tableValues.e48 * (1 / tableValues.e47)\r\n    }\r\n    // end\r\n    return newValues\r\n}\r\n\r\nexport const handleInputChange = (event, updateTablesValues, tableValues) => {\r\n    const field = event.target.id;\r\n    const newValue = Number(event.target.value);\r\n    const newValues = getCalculateNewValues(field, newValue, tableValues)\r\n    // debugger\r\n    updateTablesValues({ values: newValues })\r\n};\r\n\r\nconst handleSelectChange = (event, updateTablesValues, tableValues) => {\r\n    const field = event.target.id;\r\n    const newValue = event.target.value;\r\n    const newValues = getCalculateNewValues(field, newValue, tableValues)\r\n    updateTablesValues({ values: newValues })\r\n};\r\n\r\nconst onChangeSlider = (event, val, location, updateTablesValues, tableValues) => {\r\n    const field = location;\r\n    const newValue = val;\r\n    const newValues = getCalculateNewValues(field, newValue, tableValues)\r\n    updateTablesValues({ values: newValues })\r\n};\r\n\r\n\r\nfunction valuetext(value) {\r\n    console.log('slider value', value);\r\n\r\n    return `${value}`;\r\n}\r\n\r\nconst getMarks = (row, ) => {\r\n    if (!row) return [];\r\n    let arr = []\r\n    let i = row.min\r\n    while (i <= row.max) {\r\n        arr.push({ value: i })\r\n        i += row.ticks\r\n    }\r\n    // if we want lables in the  edges of the slider\r\n    // if (arr.length) { \r\n    //     debugger\r\n    //     arr[0].label = row.min.toString()\r\n    //     arr[arr.length - 1].label = row.max.toString()\r\n    // }\r\n    return arr\r\n}\r\n\r\nexport const renderValueType = (row, updateTablesValues, tableValues, classes) => {\r\n    const type = row.type\r\n    switch (type) {\r\n        case TYPES.NUMERIC:\r\n            return <Input\r\n                id={row.location}\r\n                label=\"Number\"\r\n                value={tableValues[row.location] || null}\r\n                onChange={(e) => handleInputChange(e, updateTablesValues, tableValues)}\r\n                type=\"number\"\r\n                className={classes.textField}\r\n\r\n            />\r\n        case TYPES.RANGE:\r\n            return <Slider\r\n                // defaultValue={row.min}//Math.floor((row.min + row.max) / 2)\r\n                getAriaValueText={valuetext}\r\n                onChange={(e, val) => onChangeSlider(e, val, row.location, updateTablesValues, tableValues)}\r\n                aria-labelledby=\"discrete-slider-always\"\r\n                step={row.ticks}\r\n                min={row.min}\r\n                max={row.max}\r\n                marks={getMarks(row)}\r\n                valueLabelDisplay=\"on\"\r\n            />\r\n        case TYPES.SELECT:\r\n            return <Select\r\n                id={row.location}\r\n                native\r\n                value={tableValues[row.location]}\r\n                onChange={(e) => handleSelectChange(e, updateTablesValues, tableValues)}\r\n            >\r\n                {row.data.map((item, i) => {\r\n                    return <option key={i} value={item}>{item}</option>\r\n                })}\r\n            </Select>\r\n        case TYPES.NOT_EDITABLE:\r\n            return <Input\r\n                id={row.location}\r\n                value={tableValues[row.location] || ''}\r\n                readOnly\r\n                className={classes.textFieldUNEditable}\r\n            />\r\n        default:\r\n            return row.type\r\n    }\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AANA;AACA;AAQA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAOA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AA1CA;AA4CA;;;;A","sourceRoot":""}